/*

This file gives Cryptol implementations for transferring between
the various bitvector domain representations and proofs of the
correctness of these operations.
*/

module bvdomain where

import arithdomain as A
import bitsdomain as B
import xordomain as X


// Operations that transfer between the domains

arithToBitDom : {n} (fin n, n >= 1) => A::Dom n -> B::Dom n
arithToBitDom a = { lomask = lo, himask = hi }
  where
  u  = A::unknowns a
  hi = a.lo || u
  lo = hi ^ u

bitToArithDom : {n} (fin n) => B::Dom n -> A::Dom n
bitToArithDom b = A::range b.lomask b.himask

bitToXorDom : {n} (fin n) => B::Dom n -> X::Dom n
bitToXorDom b = { val = b.himask, unknown = b.lomask ^ b.himask }

xorToBitDom : {n} (fin n) => X::Dom n -> B::Dom n
xorToBitDom x = { lomask = x.val ^ x.unknown, himask = x.val }

arithToXorDom : {n} (fin n, n >= 1) => A::Dom n -> X::Dom n
arithToXorDom a = { val = a.lo || u, unknown = u }
  where
  u = A::unknowns a

// A small collection of operations that start in one
// domain and end in the other

popcount : {n} (fin n, n>=1) => [n] -> [n]
popcount bs = sum [ zero#[b] | b <- bs ]

countLeadingZeros : {n} (fin n, n>=1) => [n] -> [n]
countLeadingZeros x = loop 0
 where
 loop n =
   if n >= length x then
     length x
   else
     if x@n then n else loop (n+1)

countTrailingZeros : {n} (fin n, n>=1) => [n] -> [n]
countTrailingZeros xs = countLeadingZeros (reverse xs)



popcnt : {n} (fin n, n>=1) => B::Dom n -> A::Dom n
popcnt b = A::range lo hi
  where
  lo = popcount b.lomask
  hi = popcount b.himask

clz : {n} (fin n, n>=1) => B::Dom n -> A::Dom n
clz b = A::range lo hi
 where
 lo = countLeadingZeros b.himask
 hi = countLeadingZeros b.lomask

ctz : {n} (fin n, n>=1) => B::Dom n -> A::Dom n
ctz b = A::range lo hi
 where
 lo = countTrailingZeros b.himask
 hi = countTrailingZeros b.lomask


//////////////////////////////////////////////////////////////
// Correctness properties

correct_arithToBitDom : {n} (fin n, n >= 1) => A::Dom n -> [n] -> Bit
correct_arithToBitDom a x =
  A::mem a x ==> B::mem (arithToBitDom a) x

correct_bitToArithDom : {n} (fin n) => B::Dom n -> [n] -> Bit
correct_bitToArithDom b x =
  B::mem b x ==> A::mem (bitToArithDom b) x

correct_bitToXorDom : {n} (fin n) => B::Dom n -> [n] -> Bit
correct_bitToXorDom b x =
  B::mem b x == X::mem (bitToXorDom b) x

correct_xorToBitDom : {n} (fin n) => X::Dom n -> [n] -> Bit
correct_xorToBitDom b x =
  X::mem b x == B::mem (xorToBitDom b) x

correct_arithToXorDom : {n} (fin n, n >= 1) => A::Dom n -> [n] -> Bit
correct_arithToXorDom a x =
  A::mem a x ==> X::mem (arithToXorDom a) x

property t1 = correct_arithToBitDom`{16}
property t2 = correct_bitToArithDom`{16}
property t3 = correct_bitToXorDom`{16}
property t4 = correct_xorToBitDom`{16}
property t5 = correct_arithToXorDom`{16}

correct_popcnt : {n} (fin n, n>=1) => B::Dom n -> [n] -> Bit
correct_popcnt a x =
  B::mem a x ==> A::mem (popcnt a) (popcount x)

correct_clz : {n} (fin n, n>=1) => B::Dom n -> [n] -> Bit
correct_clz a x =
  B::mem a x ==> A::mem (clz a) (countLeadingZeros x)

correct_ctz : {n} (fin n, n>=1) => B::Dom n -> [n] -> Bit
correct_ctz a x =
  B::mem a x ==> A::mem (ctz a) (countTrailingZeros x)

property w1 = correct_popcnt`{16}
property w2 = correct_clz`{16}
property w3 = correct_ctz`{16}

////////////////////////////////////////////////////////////////
// Proofs that the XOR domain is really just an alternate way
// to compute the same thing as the bitsdomain operations.
// For "band" this requires the input domains to be nonempty,
// which should be the case for all actual values of interest.

equiv_bxor : {n} (fin n) => B::Dom n -> B::Dom n -> Bit
equiv_bxor a b =
  B::bxor a b == xorToBitDom (X::bxor (bitToXorDom a) (bitToXorDom b))

equiv_band : {n} (fin n) => B::Dom n -> B::Dom n -> Bit
equiv_band a b =
  B::nonempty a /\ B::nonempty b ==>
  B::band a b == xorToBitDom (X::band (bitToXorDom a) (bitToXorDom b))

equiv_band_scalar : {n} (fin n) => B::Dom n -> [n] -> Bit
equiv_band_scalar a x =
  B::band a (B::singleton x) == xorToBitDom (X::band_scalar (bitToXorDom a) x)


property e1 = equiv_bxor`{16}
property e2 = equiv_band`{16}
property e3 = equiv_band_scalar`{16}
